# 开发历史 
我们是在四月下旬开始开发的，当时 Pierre 拉着我认识了老梁，我们仨一起参加了这个竞赛。题目是获取 coredump 并获取信息。

## 开发初期

当时我们对这玩意相当于基本不明白，然后我们查看了很多的东西。包括但不限于 DrKonqi (KDE 程序崩溃程序)，systemd-coredump 的代码，看了两天也没看明白多少。

说到 DrKonqi，我们当时一起分析了这些代码，发现这些代码需要 KCrash。于是我们又看了 KCrash 的代码，我们在那里也没有多少收获，只是知道了这玩意是工作在 systemd-coredump 上面的，而且仅对 KDE 框架开发的程序有效。

我们又看了 systemd-coredump 的代码，终于是有了些收获。

## 获取 coredump
老梁(Killtimer)从 systemd-coredump 和 /proc/sys/kernel/core_pattern 中获知，系统会将崩溃信息输出到标准输出里面。然后他写了一个很简单的 C 语言程序，来获取这些信息。这个程序基本上就是循环读取从标准输出里面获取的信息，然后保存到一个文件里面。这个程序是我们这个项目里面第一个代码，真的就是里程碑意义了。

```c
#include <stdio.h>
#include <string.h>

int main()
{
	FILE *f = fopen("/home/killtimer/Desktop/dmp.txt", "wb");
	if (f)
	{
		unsigned char buf[1024];
		size_t len;
		for (;;)
		{
			len = fread(buf, 1, 1024, stdin);
			if (!len)
				break;
			fwrite(buf, len, 1, f);
		}
		fclose(f);
	}
	return 0;
}
```

## 使用 python 获取信息

我们一开始我们想利用 systemd-coredump 暴露的接口，我们联系了出题的吉老师。吉老师说这个方法很不可行，他给了我们一些已经实现的方案，其中使用 python 开发的 apport 程序引起了我们的注意。正好 python 已经提供了很多的第三方库，来帮助我们获取信息。老梁花了两个晚上的时间，开发出了这个程序的框架。我在这个框架上面，填充了收集信息的功能，和一个输出简要信息到系统日志的功能。我把我信息的格式给他，他写出来了日志查看器。我最后是核实了一遍，确实能在 /var/log 下使用。好的，该交了。

## 最后我的想法

还行吧，虽然这一个多月的开发时间大多被学校的一堆破事给占据了。但在开发时间里，我们的工作还是很有效率的。本人不太精通 python，只能说人家给个框架，我填补一些功能。感谢 Killtimer 和 Pierre 给我这个机会吧。

SuperBart 2022-06-04



## 框架开发过程

> 实际上在一个月的开发时间中，大片的空闲时间没有多少。这个框架，实际上不算框架，因为这些基本的代码写好以后，后续开发过程中发掘出几处明显的bug。。。我们在后面的提交中已经把它们修复了，但可能仍然有更完美的解决方案。

​		吉老师提供的链接中，apport 项目引起了我的注意。这个项目主要是用 python 写的，而且被用于 Ubuntu 默认的崩溃收集。我想到的是，既然可以用 python，那应该可以引入各种各样的 python 库，这样的话应该可以帮助我们收集很多基本信息，就不用自己一个个“造轮子”了。简单测试 python 确实可以取得标准输入中的 coredump 信息。那么我们的项目总算是有一点头绪了。

​		然而想法归想法，实际上做的过程也比较难受。首先配置完`core_pattern`以后，我设法让一个程序崩溃，但是我看不到任何结果。甚至是我在程序开头就 sleep，结果还是没有对应的现象。最后我认为是在import的时候出了什么问题，因为我只 import time 这个库，发现程序终于停住了！！！然而我还是不知道程序的标准输出和标准错误是什么（文档中只提到了标准输入是 coredump 文件）。查阅资料可知，`/proc/$PID/fd`目录中保存了文件的信息，于是我开头 sleep，然后看对应位置下的文件，结果------根本就没有1和2这两个文件？！那应该就是没有标准输出什么的了。我学着 apport 中的代码进行文件重定向，最后终于在指定的文件中见到了报错信息。

​		在那之后，程序的开发就不再是两眼一抹黑了，只要根据报错修正程序就好。在查看`core_pattern`中格式化字符的定义时，我发现其中很多信息都可以通过 pid 简介获取，于是我们只选择传入了 pid，signal（最后发现这个应该也不是必须的）和 ulimit。

​		然后就有了程序的大致框架：程序分为 chandler（`core_pattern`的启动器）和 crashlib。理由是后续开发过程可能会重用一些代码，于是就分开放置了。其中 crashlib 又分为以下模块：

* config

  提供配置解析接口。

* handler

  处理 coredump 的详细过程。

* report

  主要存放日志的输出函数。

* utils

  工具类。

​		对于 handler 的实现，理想状态是对于每种信息（coredump 本体、崩溃程序的上下文、调用外部程序收集的信息、压缩过程等）分开实现，并存放在 crashlib/handler 目录的不同文件中，最后动态加载它们，这样后续没准还可以支持动态加载插件。实际上还是比较残酷：各个收集过程直接耦合性太强，很难完全独立。例如，如果先没有转存 coredump，一些收集过程就无法进行，而 coredump 的压缩，又得在 coredump 转存后，而且需要等这个文件的 handler 全部完成后才能继续。这也是一个大问题。最后我发现 python 的协程应该能解决这类问题，于是就加入了异步机制和事件通知。然后我写了 coredump 的转存，与此同时，我发现通知处理机制还是有一些小问题，但不知要怎样修正，于是采取了妥协的办法：使用@SubscribeEvent修饰器显式指定要接收的事件。这让代码复杂化了，不太令人满意，但它确实是一种可行的处理方式。

​		由于我在 linux 方面完全是一个小白，于是把所有的信息收集过程交给了十分熟悉 linux 的 Superbart。他花了几天的时间收集了很多信息，最终把它们保存在`information.json`中。然后命令行模式的崩溃记录查看器就可以开工了。

​		以现有工具`coredumpctl`为参考，我们写了命令行语法与它十分相似的`cviewer`。这个工具的开发过程风平浪静，遇到的问题也能通过各种方式解决。这时我们又找出了一个比较严重的bug：收集信息的输出目录名称与时间有关，如果收集过程持续超过一秒钟，会按不同的名称生成两个文件夹。于是我们直接获取了自身进程的启动时间作为文件夹名称的一部分，才算解决了这个问题。然而直到这时，五月已经接近尾声，我们没能实现更多功能。经过几台机器的测试，没发现什么问题，那项目的开发就告一段落了。

## 将来的计划

如果有更多时间，我们打算实现下面的功能：

* 打包项目，这样就能更方便地安装
* GUI 版本的崩溃提示服务和崩溃记录查看器
* 优化现有事件通知机制，然后实现插件功能
* 对于一些常见的程序框架（Qt，GTK等），给出更多抽象层次的信息

## 我的想法

初赛应该就写这么多了。在比赛过程中，很多知识技能都是以前不知道的，然后就现学现用，收获很大。一方面了解了 python 的一些库，以及它的模块化机制。另一方面，第一次参与开发多人合作的项目，学会了很多以前从未用到的 git 子命令。当然收获最大的还是通过 Pierre 认识了大佬 Superbart 吧。

KillTimer 2022-06-04

